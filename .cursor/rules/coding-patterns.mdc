---
globs: app/src/**/*.ts
---

# コーディングパターンとスタイル

## 🎯 コーディングスタイル

### 1. **関数の命名規則**

```typescript
// ✅ 正しい命名
async function fetch[Features](): Promise<Fetch[Features]Result>
async function fetch[Feature]ById(id: string): Promise<Fetch[Feature]Result>
function clearCache(): void
function getCacheStats(): object

// ❌ 避けるべき命名
async function get[Features]()  // 曖昧
async function fetch()          // 具体的でない
```

### 2. **型定義の規則**

```typescript
// ✅ 統一された結果型
export interface FetchResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  metadata?: {
    timestamp: Date;
    executionTime: number;
    cacheHit?: boolean;
  };
}

// ✅ 型エイリアスの使用
export type Fetch[Features]Result = FetchResult<[Feature][]>;
export type Fetch[Feature]Result = FetchResult<[Feature]>;
```

### 3. **エラーハンドリングのパターン**

```typescript
// ✅ 統一されたエラーハンドリング
try {
  const data = await someOperation();
  return {
    success: true,
    data,
    metadata: {
      timestamp: new Date(),
      executionTime: Date.now() - startTime,
    },
  };
} catch (error) {
  const executionTime = Date.now() - startTime;
  logger.error('操作エラー', error as Error, { executionTime });

  if (error instanceof [Feature]Error) {
    return {
      success: false,
      error: error.message,
      metadata: { timestamp: new Date(), executionTime },
    };
  }

  return {
    success: false,
    error: `不明なエラーが発生しました: ${error}`,
    metadata: { timestamp: new Date(), executionTime },
  };
}
```

## 🏗️ アーキテクチャパターン

### 1. **Repository パターンの実装**

```typescript
export class [Feature]Repository {
  // ✅ 依存性注入によるコンストラクタ
  constructor(
    private service: [Feature]Service,
    private mapper: [Feature]Mapper,
    private logger: ILogger,
    private cache: ICache<[Feature][]>
  ) {}

  // ✅ キャッシュ付きデータ取得
  async fetch[Features](id: string): Promise<[Feature][]> {
    const cacheKey = `[features]:${id}`;

    // キャッシュチェック
    const cached = this.cache.get(cacheKey);
    if (cached) {
      this.logger.debug(`キャッシュから取得: ${cacheKey}`);
      return cached;
    }

    // データ取得
    this.logger.info(`データベース ${id} から取得中`);
    const data = await this.service.queryData(id);

    // 変換処理
    const [features] = await Promise.all(
      data.results.map(async (item) => {
        const content = await this.service.getContent(item.id);
        return await this.mapper.mapTo[Feature](item, content);
      })
    );

    // キャッシュ保存
    this.cache.set(cacheKey, [features]);
    return [features];
  }
}
```

### 2. **Service パターンの実装**

```typescript
export class [Feature]Service {
  // ✅ リトライ機能付きAPI呼び出し
  async queryData(id: string): Promise<[Feature]Response> {
    ValidatorFactory.validateId(id);

    const cacheKey = `data:${id}`;
    const cached = this.cache.get(cacheKey);
    if (cached) {
      this.logger.debug(`キャッシュから取得: ${cacheKey}`);
      return cached;
    }

    this.logger.info(`APIから取得: ${id}`);

    return await this.retryManager.execute(async () => {
      const response = await this.externalApi.query({
        id: id,
      });

      this.cache.set(cacheKey, response);
      return response;
    });
  }
}
```

### 3. **Mapper パターンの実装**

```typescript
export class [Feature]Mapper {
  // ✅ 型安全な変換
  async mapTo[Feature](data: [Feature]Response, content: ContentResponse): Promise<[Feature]> {
    try {
      this.logger.debug(`データ ${data.id} を変換中`);

      const [feature] = this.create[Feature]Model(data, content);
      ValidatorFactory.validate[Feature]([feature]);

      this.logger.debug(`変換完了: ${data.id}`);
      return [feature];
    } catch (error) {
      this.logger.error(`変換エラー: ${data.id}`, error as Error);
      throw new [Feature]Error(
        `データ ${data.id} の変換に失敗しました`,
        ERROR_CODES.MAPPING_ERROR,
        { dataId: data.id, error: error instanceof Error ? error.message : 'Unknown error' }
      );
    }
  }

  // ✅ プライベートメソッドでの詳細実装
  private create[Feature]Model(data: [Feature]Response, content: ContentResponse): [Feature] {
    return {
      name: this.extractName(data),
      // その他のプロパティ
      content,
    };
  }
}
```

## 🔧 実装パターン

### 1. **キャッシュパターン**

```typescript
// ✅ 統一されたキャッシュパターン
async function getDataWithCache<T>(
  cacheKey: string,
  cache: ICache<T>,
  fetchFunction: () => Promise<T>
): Promise<T> {
  const cached = cache.get(cacheKey);
  if (cached) {
    logger.debug(`キャッシュヒット: ${cacheKey}`);
    return cached;
  }

  logger.info(`データ取得中: ${cacheKey}`);
  const data = await fetchFunction();
  cache.set(cacheKey, data);
  return data;
}
```

### 2. **リトライパターン**

```typescript
// ✅ 統一されたリトライパターン
async function executeWithRetry<T>(
  operation: () => Promise<T>,
  retryManager: RetryManager,
  context: string
): Promise<T> {
  return await retryManager.execute(async () => {
    logger.debug(`${context} を実行中`);
    return await operation();
  });
}
```

### 3. **バリデーションパターン**

```typescript
// ✅ 統一されたバリデーションパターン
function validateAndTransform<T>(
  data: any,
  validator: (data: any) => boolean,
  transformer: (data: any) => T,
  errorMessage: string
): T {
  if (!validator(data)) {
    throw new FetchError(errorMessage, ERROR_CODES.VALIDATION_ERROR);
  }

  try {
    return transformer(data);
  } catch (error) {
    throw new FetchError(
      `変換エラー: ${errorMessage}`,
      ERROR_CODES.TRANSFORMATION_ERROR,
      { originalError: error instanceof Error ? error.message : 'Unknown error' }
    );
  }
}
```

## 📋 必須実装項目

### 1. **すべてのクラスで必須**

```typescript
// ✅ 必須: 依存性注入コンストラクタ
constructor(
  private logger: ILogger,
  // その他の依存関係
) {}

// ✅ 必須: ログ出力
this.logger.info('操作開始', { context });
this.logger.debug('詳細情報', { data });
this.logger.error('エラー発生', error, { context });

// ✅ 必須: エラーハンドリング
try {
  // 操作
} catch (error) {
  this.logger.error('操作エラー', error as Error, { context });
  throw new FetchError('エラーメッセージ', ERROR_CODES.SPECIFIC_ERROR);
}
```

### 2. **Repository層で必須**

```typescript
// ✅ 必須: キャッシュ機能
const cacheKey = `resource:${identifier}`;
const cached = this.cache.get(cacheKey);
if (cached) return cached;

// ✅ 必須: データ取得とキャッシュ保存
const data = await this.fetchData();
this.cache.set(cacheKey, data);
return data;
```

### 3. **Service層で必須**

```typescript
// ✅ 必須: バリデーション
ValidatorFactory.validateInput(input);

// ✅ 必須: リトライ機能
return await this.retryManager.execute(async () => {
  return await this.externalApiCall();
});
```

### 4. **Mapper層で必須**

```typescript
// ✅ 必須: 型安全な変換
const model = this.createModel(data);
ValidatorFactory.validateModel(model);
return model;

// ✅ 必須: エラー時の詳細ログ
catch (error) {
  this.logger.error(`変換エラー: ${identifier}`, error as Error);
  throw new FetchError(`変換失敗: ${identifier}`, ERROR_CODES.MAPPING_ERROR);
}
```

## 🚫 禁止パターン

### 1. **直接的な依存関係**

```typescript
// ❌ 禁止: 直接インスタンス化
const service = new NotionDatabaseService(...);

// ❌ 禁止: 循環依存
class ServiceA {
  constructor(private serviceB: ServiceB) {}
}
class ServiceB {
  constructor(private serviceA: ServiceA) {}  // 循環依存
}
```

### 2. **エラーハンドリングの不備**

```typescript
// ❌ 禁止: エラーの無視
try {
  await operation();
} catch (error) {
  // 何もしない - 禁止
}

// ❌ 禁止: 一般的なError
throw new Error('エラー');  // FetchErrorを使用すべき
```

### 3. **バリデーションの省略**

```typescript
// ❌ 禁止: バリデーションなし
return { name: data.name };  // バリデーション必須

// ❌ 禁止: 型安全性の無視
function processData(data: any) {  // 具体的な型を使用すべき
  return data.someProperty;
}
```

## 📚 参考実装

- [fetch.ts](mdc:app/src/domain/fetch/fetch.ts) - メインAPIの実装例
- [HabitRepository.ts](mdc:app/src/domain/fetch/repositories/HabitRepository.ts) - Repositoryパターン
- [NotionDatabaseService.ts](mdc:app/src/domain/fetch/services/NotionDatabaseService.ts) - Serviceパターン
- [HabitMapper.ts](mdc:app/src/domain/fetch/mappers/HabitMapper.ts) - Mapperパターン
- [ServiceFactory.ts](mdc:app/src/domain/fetch/factories/ServiceFactory.ts) - Factoryパターン
